/**
 * Report renderer for clearance-opinion-engine.
 *
 * Produces JSON + Markdown + HTML + Summary JSON from a run object.
 */

import { mkdirSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { renderPacketHtml, renderSummaryJson } from "./packet.mjs";

/**
 * Write a run to disk as JSON + Markdown + HTML + Summary.
 *
 * @param {object} run - Complete run object (per schema)
 * @param {string} outDir - Directory to write files to
 * @returns {{ jsonPath: string, mdPath: string, htmlPath: string, summaryPath: string }}
 */
export function writeRun(run, outDir) {
  mkdirSync(outDir, { recursive: true });

  const jsonPath = join(outDir, "run.json");
  writeFileSync(jsonPath, JSON.stringify(run, null, 2) + "\n", "utf8");

  const mdPath = join(outDir, "run.md");
  writeFileSync(mdPath, renderRunMd(run), "utf8");

  const htmlPath = join(outDir, "report.html");
  writeFileSync(htmlPath, renderPacketHtml(run), "utf8");

  const summaryPath = join(outDir, "summary.json");
  const summaryObj = renderSummaryJson(run);
  writeFileSync(summaryPath, JSON.stringify(summaryObj, null, 2) + "\n", "utf8");

  return { jsonPath, mdPath, htmlPath, summaryPath };
}

/**
 * Render a run object as Markdown.
 *
 * @param {object} run - Complete run object
 * @returns {string} Markdown string
 */
export function renderRunMd(run) {
  const lines = [];
  const opinion = run.opinion || {};
  const tierEmoji =
    opinion.tier === "green" ? "\u{1F7E2}" : opinion.tier === "yellow" ? "\u{1F7E1}" : "\u{1F534}";
  const tierLabel = (opinion.tier || "unknown").toUpperCase();

  // Header
  const candidateNames = run.intake?.candidates?.map((c) => c.mark).join(", ") || "unknown";
  lines.push(`# Clearance Report: ${candidateNames}`);
  lines.push("");
  lines.push(`> Generated by clearance.opinion.engine v${run.run?.engineVersion || "0.1.0"}`);
  lines.push(`> Run ID: \`${run.run?.runId || "unknown"}\``);
  lines.push(`> Created: ${run.run?.createdAt || "unknown"}`);
  lines.push("");

  // Opinion
  lines.push(`## Opinion: ${tierEmoji} ${tierLabel}`);
  lines.push("");
  lines.push(opinion.summary || "No summary available.");
  lines.push("");

  // Reasons
  if (opinion.reasons?.length > 0) {
    lines.push("### Reasons");
    lines.push("");
    for (const r of opinion.reasons) {
      lines.push(`- ${r}`);
    }
    lines.push("");
  }

  // Score Breakdown
  const breakdown = opinion.scoreBreakdown;
  if (breakdown && breakdown.overallScore !== undefined) {
    lines.push("### Score Breakdown");
    lines.push("");
    lines.push("| Factor | Score | Weight | Details |");
    lines.push("|--------|-------|--------|---------|");

    const factors = [
      ["Namespace Availability", breakdown.namespaceAvailability],
      ["Coverage Completeness", breakdown.coverageCompleteness],
      ["Conflict Severity", breakdown.conflictSeverity],
      ["Domain Availability", breakdown.domainAvailability],
    ];

    for (const [label, sub] of factors) {
      if (sub) {
        lines.push(`| ${label} | ${sub.score}/100 | ${sub.weight}% | ${sub.details} |`);
      }
    }
    lines.push("");

    let overallLine = `**Overall Score: ${breakdown.overallScore}/100**`;
    if (breakdown.tierThresholds) {
      overallLine += ` (Green threshold: ${breakdown.tierThresholds.green})`;
    }
    lines.push(overallLine);
    lines.push("");
  }

  // Namespace Checks
  if (run.checks?.length > 0) {
    lines.push("## Namespace Checks");
    lines.push("");
    lines.push("| Namespace | Name | Status | Authority |");
    lines.push("|-----------|------|--------|-----------|");
    for (const c of run.checks) {
      const statusIcon =
        c.status === "available" ? "\u2705" : c.status === "taken" ? "\u274C" : "\u2753";
      lines.push(
        `| ${c.namespace} | \`${c.query?.value || ""}\` | ${statusIcon} ${c.status} | ${c.authority} |`
      );
    }
    lines.push("");
  }

  // Variants
  if (run.variants?.items?.length > 0) {
    lines.push("## Variants Checked");
    lines.push("");
    for (const vs of run.variants.items) {
      lines.push(`### \`${vs.candidateMark}\``);
      lines.push("");
      lines.push(`Canonical: \`${vs.canonical}\``);
      lines.push("");
      lines.push("| Type | Value |");
      lines.push("|------|-------|");
      for (const f of vs.forms) {
        lines.push(`| ${f.type} | \`${f.value}\` |`);
      }
      lines.push("");

      if (vs.warnings?.length > 0) {
        lines.push("**Warnings:**");
        for (const w of vs.warnings) {
          lines.push(`- \`${w.code}\` (${w.severity}): ${w.message}`);
        }
        lines.push("");
      }
    }
  }

  // Findings
  if (run.findings?.length > 0) {
    lines.push("## Findings");
    lines.push("");
    for (const f of run.findings) {
      const severityIcon =
        f.severity === "high" ? "\u{1F534}" : f.severity === "medium" ? "\u{1F7E1}" : "\u{1F7E2}";
      lines.push(`### ${severityIcon} ${f.kind} (${f.severity})`);
      lines.push("");
      lines.push(f.summary);
      if (f.why?.length > 0) {
        lines.push("");
        for (const w of f.why) {
          lines.push(`- ${w}`);
        }
      }
      lines.push("");
    }
  }

  // Recommended Actions
  if (opinion.recommendedActions?.length > 0) {
    lines.push("## Recommended Actions");
    lines.push("");
    for (let i = 0; i < opinion.recommendedActions.length; i++) {
      const a = opinion.recommendedActions[i];
      lines.push(`${i + 1}. **${a.label}** (\`${a.type}\`)`);
      if (a.details) lines.push(`   ${a.details}`);
      if (a.links?.length > 0) {
        for (const link of a.links) {
          lines.push(`   - ${link}`);
        }
      }
    }
    lines.push("");
  }

  // Closest Conflicts
  if (opinion.closestConflicts?.length > 0) {
    lines.push("## Closest Conflicts");
    lines.push("");
    for (const cc of opinion.closestConflicts) {
      lines.push(`- **${cc.mark}** (${cc.severity})`);
      for (const w of cc.why) {
        lines.push(`  - ${w}`);
      }
    }
    lines.push("");
  }

  // Evidence Chain
  if (run.evidence?.length > 0) {
    lines.push("## Evidence Chain");
    lines.push("");
    lines.push("| ID | Type | System | URL | SHA-256 |");
    lines.push("|----|------|--------|-----|---------|");
    for (const e of run.evidence) {
      const url = e.source?.url || "-";
      const sha = e.sha256 ? `\`${e.sha256.slice(0, 12)}...\`` : "-";
      lines.push(`| \`${e.id}\` | ${e.type} | ${e.source?.system || "-"} | ${url} | ${sha} |`);
    }
    lines.push("");
  }

  // Assumptions & Limitations
  if (opinion.assumptions?.length > 0) {
    lines.push("## Assumptions");
    lines.push("");
    for (const a of opinion.assumptions) {
      lines.push(`- ${a}`);
    }
    lines.push("");
  }

  if (opinion.limitations?.length > 0) {
    lines.push("## Limitations");
    lines.push("");
    for (const l of opinion.limitations) {
      lines.push(`- ${l}`);
    }
    lines.push("");
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push("*This report is an automated opinion based on namespace availability checks.*");
  lines.push("*It is not legal advice. Consult a trademark professional for definitive guidance.*");
  lines.push("");

  return lines.join("\n");
}
