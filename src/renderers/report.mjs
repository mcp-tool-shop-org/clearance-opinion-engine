/**
 * Report renderer for clearance-opinion-engine.
 *
 * Produces JSON + Markdown + HTML + Summary JSON from a run object.
 */

import { mkdirSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { renderPacketHtml, renderSummaryJson } from "./packet.mjs";
import { checkFreshness } from "../lib/freshness.mjs";

/**
 * Escape pipe characters for Markdown table cells.
 * @param {string} str
 * @returns {string}
 */
function escapeForMd(str) {
  if (typeof str !== "string") return "";
  return str.replace(/\|/g, "\\|");
}

/**
 * Write a run to disk as JSON + Markdown + HTML + Summary.
 *
 * @param {object} run - Complete run object (per schema)
 * @param {string} outDir - Directory to write files to
 * @returns {{ jsonPath: string, mdPath: string, htmlPath: string, summaryPath: string }}
 */
export function writeRun(run, outDir) {
  mkdirSync(outDir, { recursive: true });

  const jsonPath = join(outDir, "run.json");
  writeFileSync(jsonPath, JSON.stringify(run, null, 2) + "\n", "utf8");

  const mdPath = join(outDir, "run.md");
  writeFileSync(mdPath, renderRunMd(run), "utf8");

  const htmlPath = join(outDir, "report.html");
  writeFileSync(htmlPath, renderPacketHtml(run), "utf8");

  const summaryPath = join(outDir, "summary.json");
  const summaryObj = renderSummaryJson(run);
  writeFileSync(summaryPath, JSON.stringify(summaryObj, null, 2) + "\n", "utf8");

  return { jsonPath, mdPath, htmlPath, summaryPath };
}

/**
 * Render a run object as Markdown.
 *
 * @param {object} run - Complete run object
 * @returns {string} Markdown string
 */
export function renderRunMd(run, opts = {}) {
  const lines = [];
  const opinion = run.opinion || {};
  const tierEmoji =
    opinion.tier === "green" ? "\u{1F7E2}" : opinion.tier === "yellow" ? "\u{1F7E1}" : "\u{1F534}";
  const tierLabel = (opinion.tier || "unknown").toUpperCase();

  // Header
  const candidateNames = run.intake?.candidates?.map((c) => c.mark).join(", ") || "unknown";
  lines.push(`# Clearance Report: ${candidateNames}`);
  lines.push("");
  lines.push(`> Generated by clearance.opinion.engine v${run.run?.engineVersion || "0.1.0"}`);
  lines.push(`> Run ID: \`${run.run?.runId || "unknown"}\``);
  lines.push(`> Created: ${run.run?.createdAt || "unknown"}`);
  lines.push("");

  // Opinion
  lines.push(`## Opinion: ${tierEmoji} ${tierLabel}`);
  lines.push("");
  lines.push(opinion.summary || "No summary available.");
  lines.push("");

  // Coverage (conditional)
  if (opinion.coverageScore !== undefined) {
    const checkedCount = (run.checks || []).filter((c) => c.status !== "unknown" && !c.query?.isVariant).length;
    const totalCount = (run.checks || []).filter((c) => !c.query?.isVariant).length;
    let coverageLine = `> **Coverage:** ${opinion.coverageScore}% | ${checkedCount}/${totalCount} namespaces checked`;
    if (opinion.uncheckedNamespaces?.length > 0) {
      coverageLine += ` | Not checked: ${opinion.uncheckedNamespaces.join(", ")}`;
    }
    lines.push(coverageLine);
    lines.push("");
  }

  // Freshness Warning (conditional)
  {
    const freshness = checkFreshness(run, { maxAgeHours: 24, now: opts.now });
    if (freshness.isStale) {
      lines.push(`> **\u26A0\uFE0F Freshness Warning:** ${freshness.banner}`);
      lines.push("");
    }
  }

  // Executive Summary
  lines.push("## Executive Summary");
  lines.push("");
  const availableCount = run.checks?.filter((c) => c.status === "available").length || 0;
  const takenCount = run.checks?.filter((c) => c.status === "taken").length || 0;
  const unknownCount = run.checks?.filter((c) => c.status === "unknown").length || 0;
  const totalChecks = run.checks?.length || 0;
  const overallScore = opinion.scoreBreakdown?.overallScore;
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Tier | ${tierEmoji} ${tierLabel} |`);
  if (overallScore !== undefined) {
    lines.push(`| Overall Score | ${overallScore}/100 |`);
  }
  lines.push(`| Namespaces Checked | ${totalChecks} |`);
  lines.push(`| Available | ${availableCount} |`);
  lines.push(`| Taken | ${takenCount} |`);
  lines.push(`| Unknown | ${unknownCount} |`);
  lines.push(`| Findings | ${run.findings?.length || 0} |`);
  lines.push("");
  if (opinion.recommendedActions?.length > 0) {
    lines.push(`**Top Action:** ${opinion.recommendedActions[0].label}`);
    lines.push("");
  }
  if (opinion.closestConflicts?.length > 0) {
    const topConflicts = opinion.closestConflicts.slice(0, 2);
    lines.push("**Top Conflicts:**");
    for (const cc of topConflicts) {
      lines.push(`- ${cc.mark} (${cc.severity})`);
    }
    lines.push("");
  }

  // Coverage Matrix
  lines.push("## Coverage Matrix");
  lines.push("");
  lines.push("| Source | Namespace | Status | Authority |");
  lines.push("|--------|-----------|--------|-----------|");
  if (run.checks?.length > 0) {
    for (const c of run.checks) {
      const source = c.details?.source || c.namespace;
      const statusIcon =
        c.status === "available" ? "\u2705" : c.status === "taken" ? "\u274C" : "\u2753";
      const cacheTag = c.cacheHit ? " (cached)" : "";
      lines.push(
        `| ${source} | ${c.namespace} | ${statusIcon} ${c.status}${cacheTag} | ${c.authority} |`
      );
    }
  } else {
    lines.push("| - | - | - | - |");
  }
  lines.push("");

  // Reasons
  if (opinion.reasons?.length > 0) {
    lines.push("### Reasons");
    lines.push("");
    for (const r of opinion.reasons) {
      lines.push(`- ${r}`);
    }
    lines.push("");
  }

  // Score Breakdown
  const breakdown = opinion.scoreBreakdown;
  if (breakdown && breakdown.overallScore !== undefined) {
    lines.push("### Score Breakdown");
    lines.push("");
    lines.push("| Factor | Score | Weight | Details |");
    lines.push("|--------|-------|--------|---------|");

    const factors = [
      ["Namespace Availability", breakdown.namespaceAvailability],
      ["Coverage Completeness", breakdown.coverageCompleteness],
      ["Conflict Severity", breakdown.conflictSeverity],
      ["Domain Availability", breakdown.domainAvailability],
    ];

    for (const [label, sub] of factors) {
      if (sub) {
        lines.push(`| ${label} | ${sub.score}/100 | ${sub.weight}% | ${sub.details} |`);
      }
    }
    lines.push("");

    let overallLine = `**Overall Score: ${breakdown.overallScore}/100**`;
    if (breakdown.tierThresholds) {
      overallLine += ` (Green threshold: ${breakdown.tierThresholds.green})`;
    }
    lines.push(overallLine);
    lines.push("");
  }

  // Top Factors
  if (opinion.topFactors?.length > 0) {
    lines.push("### Top Factors");
    lines.push("");
    lines.push("| # | Factor | Statement | Weight |");
    lines.push("|---|--------|-----------|--------|");
    opinion.topFactors.forEach((tf, i) => {
      lines.push(`| ${i + 1} | ${escapeForMd(tf.factor)} | ${escapeForMd(tf.statement)} | ${escapeForMd(tf.weight)} |`);
    });
    lines.push("");
  }

  // Risk Narrative
  if (opinion.riskNarrative) {
    lines.push("### Risk Narrative");
    lines.push("");
    lines.push(`> ${opinion.riskNarrative}`);
    lines.push("");
  }

  // DuPont-Lite Analysis
  if (breakdown?.dupontFactors) {
    const df = breakdown.dupontFactors;
    const dupontRows = [
      ["Similarity of Marks", df.similarityOfMarks],
      ["Channel Overlap", df.channelOverlap],
      ["Fame Proxy", df.fameProxy],
      ["Intent Proxy", df.intentProxy],
    ];
    const hasData = dupontRows.some(([, f]) => f && f.score > 0);
    if (hasData) {
      lines.push("### DuPont-Lite Analysis");
      lines.push("");
      lines.push("| Factor | Score | Rationale |");
      lines.push("|--------|-------|-----------|");
      for (const [label, factor] of dupontRows) {
        if (factor) {
          lines.push(`| ${label} | ${factor.score}/100 | ${escapeForMd(factor.rationale)} |`);
        }
      }
      lines.push("");
    }
  }

  // Namespace Checks
  if (run.checks?.length > 0) {
    lines.push("## Namespace Checks");
    lines.push("");
    lines.push("| Namespace | Name | Status | Authority |");
    lines.push("|-----------|------|--------|-----------|");
    for (const c of run.checks) {
      const statusIcon =
        c.status === "available" ? "\u2705" : c.status === "taken" ? "\u274C" : "\u2753";
      lines.push(
        `| ${c.namespace} | \`${c.query?.value || ""}\` | ${statusIcon} ${c.status} | ${c.authority} |`
      );
    }
    lines.push("");
  }

  // Variants
  if (run.variants?.items?.length > 0) {
    lines.push("## Variants Checked");
    lines.push("");
    for (const vs of run.variants.items) {
      lines.push(`### \`${vs.candidateMark}\``);
      lines.push("");
      lines.push(`Canonical: \`${vs.canonical}\``);
      lines.push("");
      lines.push("| Type | Value |");
      lines.push("|------|-------|");
      for (const f of vs.forms) {
        lines.push(`| ${f.type} | \`${f.value}\` |`);
      }
      lines.push("");

      if (vs.warnings?.length > 0) {
        lines.push("**Warnings:**");
        for (const w of vs.warnings) {
          lines.push(`- \`${w.code}\` (${w.severity}): ${w.message}`);
        }
        lines.push("");
      }
    }
  }

  // Findings
  if (run.findings?.length > 0) {
    lines.push("## Findings");
    lines.push("");
    for (const f of run.findings) {
      const severityIcon =
        f.severity === "high" ? "\u{1F534}" : f.severity === "medium" ? "\u{1F7E1}" : "\u{1F7E2}";
      lines.push(`### ${severityIcon} ${f.kind} (${f.severity})`);
      lines.push("");
      lines.push(f.summary);
      if (f.why?.length > 0) {
        lines.push("");
        for (const w of f.why) {
          lines.push(`- ${w}`);
        }
      }
      lines.push("");
    }
  }

  // Collision Details (cards)
  const collisionCards = run.opinion?.collisionCards || [];
  if (collisionCards.length > 0) {
    lines.push("## Collision Details");
    lines.push("");
    for (const card of collisionCards) {
      const severityTag = card.severity.toUpperCase();
      lines.push(`### ${severityTag}: ${card.title}`);
      lines.push("");
      lines.push(`**Why it matters:** ${card.whyItMatters}`);
      lines.push("");
      if (card.evidence?.length > 0) {
        for (const ev of card.evidence) {
          const urlPart = ev.url ? ` — ${ev.url}` : "";
          lines.push(`- ${ev.namespace}: \`${ev.name}\`${urlPart}`);
        }
        lines.push("");
      }
    }
  }

  // Collision Radar Signals (conditional)
  const radarChecks = (run.checks || []).filter(
    (c) => c.namespace === "custom" && (c.details?.source === "github_search" || c.details?.source === "npm_search")
  );
  if (radarChecks.length > 0) {
    lines.push("## Collision Radar Signals");
    lines.push("");
    lines.push("*Indicative market-usage signals — not authoritative trademark searches.*");
    lines.push("");
    lines.push("| Source | Name | Similarity | Details |");
    lines.push("|--------|------|-----------|---------|");
    for (const c of radarChecks) {
      const sim = c.details?.similarity;
      const simScore = sim?.overall !== undefined ? `${(sim.overall * 100).toFixed(0)}%` : "-";
      const source = escapeForMd(c.details?.source || "unknown");
      const name = escapeForMd(c.query?.value || "");
      const looksLabel = sim?.looks?.label || "-";
      const soundsLabel = sim?.sounds?.label || "-";
      lines.push(`| ${source} | \`${name}\` | ${simScore} | looks: ${looksLabel}, sounds: ${soundsLabel} |`);
    }
    lines.push("");
  }

  // Corpus Comparison (conditional)
  const corpusEvidence = (run.evidence || []).filter(
    (e) => e.source?.system === "user_corpus"
  );
  const corpusFindings = (run.findings || []).filter(
    (f) => f.why?.some((w) => w.includes("Commercial impression"))
  );
  if (corpusEvidence.length > 0 || corpusFindings.length > 0) {
    lines.push("## Corpus Comparison");
    lines.push("");
    lines.push("*Comparison against user-provided known marks.*");
    lines.push("");
    if (corpusFindings.length > 0) {
      for (const f of corpusFindings) {
        const severityIcon =
          f.severity === "high" ? "\u{1F534}" : f.severity === "medium" ? "\u{1F7E1}" : "\u{1F7E2}";
        lines.push(`- ${severityIcon} **${f.kind}** (${f.severity}): ${f.summary}`);
      }
      lines.push("");
    } else {
      lines.push("No similar marks found in the provided corpus.");
      lines.push("");
    }
  }

  // Fuzzy Variants Checked (conditional)
  const fuzzyChecks = (run.checks || []).filter((c) => c.query?.isVariant);
  if (fuzzyChecks.length > 0) {
    lines.push("## Fuzzy Variants Checked");
    lines.push("");
    lines.push("*Edit-distance=1 variants queried against registries for typosquatting risk.*");
    lines.push("");
    lines.push("| Variant | Registry | Status |");
    lines.push("|---------|----------|--------|");
    for (const c of fuzzyChecks) {
      const statusIcon =
        c.status === "available" ? "\u2705" : c.status === "taken" ? "\u274C" : "\u2753";
      lines.push(`| \`${c.query?.value || ""}\` | ${c.namespace} | ${statusIcon} ${c.status} |`);
    }
    lines.push("");
  }

  // Fuzzy Variants Generated (Not Checked)
  const fuzzyAll = run.variants?.items?.[0]?.fuzzyVariants || [];
  const fuzzyCheckedValues = new Set(fuzzyChecks.map((c) => c.query?.value));
  const fuzzyUnchecked = fuzzyAll.filter((v) => !fuzzyCheckedValues.has(v));
  if (fuzzyUnchecked.length > 0) {
    lines.push("## Fuzzy Variants (Not Checked)");
    lines.push("");
    const shown = fuzzyUnchecked.slice(0, 10);
    const remaining = fuzzyUnchecked.length - shown.length;
    lines.push(shown.map((v) => `\`${v}\``).join(", "));
    if (remaining > 0) {
      lines.push(`+${remaining} more`);
    }
    lines.push("");
  }

  // Recommended Actions
  if (opinion.recommendedActions?.length > 0) {
    lines.push("## Recommended Actions");
    lines.push("");
    for (let i = 0; i < opinion.recommendedActions.length; i++) {
      const a = opinion.recommendedActions[i];
      lines.push(`${i + 1}. **${a.label}** (\`${a.type}\`)`);
      if (a.details) lines.push(`   ${a.details}`);
      if (a.links?.length > 0) {
        for (const link of a.links) {
          lines.push(`   - ${link}`);
        }
      }
    }
    lines.push("");
  }

  // Next Actions
  if (opinion.nextActions?.length > 0) {
    lines.push("## Next Actions");
    lines.push("");
    const urgencyIcon = { high: "\u{1F534}", medium: "\u{1F7E1}", low: "\u{1F7E2}" };
    for (let i = 0; i < opinion.nextActions.length; i++) {
      const a = opinion.nextActions[i];
      const icon = urgencyIcon[a.urgency] || "\u2753";
      lines.push(`${i + 1}. ${icon} **${a.label}** — ${a.reason}`);
    }
    lines.push("");
  }

  // Safer Alternatives
  if (opinion.saferAlternatives?.length > 0) {
    lines.push("## Safer Alternatives");
    lines.push("");
    lines.push("| # | Name | Strategy | Availability |");
    lines.push("|---|------|----------|--------------|");
    opinion.saferAlternatives.forEach((alt, i) => {
      const avail = alt.availability?.summary || "Not checked";
      lines.push(`| ${i + 1} | \`${escapeForMd(alt.name)}\` | ${escapeForMd(alt.strategy)} | ${escapeForMd(avail)} |`);
    });
    lines.push("");
  }

  // Closest Conflicts
  if (opinion.closestConflicts?.length > 0) {
    lines.push("## Closest Conflicts");
    lines.push("");
    for (const cc of opinion.closestConflicts) {
      lines.push(`- **${cc.mark}** (${cc.severity})`);
      for (const w of cc.why) {
        lines.push(`  - ${w}`);
      }
    }
    lines.push("");
  }

  // Evidence Chain
  if (run.evidence?.length > 0) {
    lines.push("## Evidence Chain");
    lines.push("");
    lines.push("| ID | Type | System | URL | SHA-256 |");
    lines.push("|----|------|--------|-----|---------|");
    for (const e of run.evidence) {
      const url = e.source?.url || "-";
      const sha = e.sha256 ? `\`${e.sha256.slice(0, 12)}...\`` : "-";
      lines.push(`| \`${e.id}\` | ${e.type} | ${e.source?.system || "-"} | ${url} | ${sha} |`);
    }
    lines.push("");
  }

  // Assumptions & Limitations
  if (opinion.assumptions?.length > 0) {
    lines.push("## Assumptions");
    lines.push("");
    for (const a of opinion.assumptions) {
      lines.push(`- ${a}`);
    }
    lines.push("");
  }

  if (opinion.limitations?.length > 0) {
    lines.push("## Limitations");
    lines.push("");
    for (const l of opinion.limitations) {
      lines.push(`- ${l}`);
    }
    lines.push("");
  }

  // Disclaimer
  if (opinion.disclaimer) {
    lines.push("## Disclaimer");
    lines.push("");
    lines.push(`> ${opinion.disclaimer}`);
    lines.push("");
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push("*This report is an automated opinion based on namespace availability checks.*");
  lines.push("*It is not legal advice. Consult a trademark professional for definitive guidance.*");
  lines.push("");

  return lines.join("\n");
}
